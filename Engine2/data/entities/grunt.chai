var gruntScript = EntityScript();

global GruntActionType_None = 0;
global GruntActionType_Attack = 1;

class GruntState 
{
    var actionType;
    // ivec2 
    var targetHex;

    var hasActedThisRound;

    def GruntState(entity)
    {
        this.actionType = GruntActionType_None;
        this.hasActedThisRound = false;
    }
}

def gruntAttack(target) {

    var instigator = game.getSelectedEntity();

    if(instigator.is_var_null || target.is_var_null)
    {
        return;
    }

    instigator.scriptState.targetHex = target.tileIndex;

    instigator.attackPointsLeft -= 1;
    instigator.turnTowards(target.tileIndex);
    instigator.playAction("fire");
    instigator.scriptState.actionType = GruntActionType_Attack;
    game.beginCustomAction();
}

gruntScript.setCreateState(fun(entity){
    return GruntState(entity);
});

gruntScript.setOnActionTrigger(fun(entity, action, trigger){

    var targetEntity = game.entityAtHex(LI_Unit, entity.scriptState.targetHex);

    var isShotTrigger = action == "fire" && trigger == "shot";
    var isAttacking = entity.scriptState.actionType == GruntActionType_Attack;
    var isTargetValid = !targetEntity.is_var_null;

    if(isShotTrigger && isAttacking && isTargetValid)
    {
        var attackMeta = calculateAttackMeta(entity, targetEntity);
        if(attackMeta.targetDamage > 0.0)
        {
            game.applyDamage(targetEntity, entity, attackMeta.targetDamage);
        }

        if(attackMeta.instigatorDamage > 0.0)
        {
            game.applyDamage(entity,targetEntity, attackMeta.instigatorDamage);
        }
    }
});

gruntScript.setUpdateCustomAction(fun(entity, time) {

    if(entity.health > 0.0)
    {
        if(entity.scriptState.actionType == GruntActionType_Attack)
        {
            if(!entity.isActionPlaying("fire"))
            {
                entity.scriptState.actionType = GruntActionType_None;
                game.endCustomAction();
            }

            return;
        }
    }
    // we probably dont wanna get stuck in an invalid state here, so this line prob doesnt hurt
    game.endCustomAction();
});

gruntScript.setOnHit(fun(entity, instigator, damage){

    entity.turnTowards(instigator.tileIndex);

    entity.health -= damage;

    if(entity.health < 0.0)
    {
        game.killEntity(entity);
    }
    else 
    {
        entity.playAction("hit");
    }
});

gruntScript.setOnTargetChanged(fun(entity, newTarget){
    entity.scriptState.targetHex = newTarget;
});

gruntScript.setOnTargetClicked(fun(entity){
    game.endTargeting();

    var targetEntity = game.entityAtHex(LI_Unit, entity.scriptState.targetHex);
    if(targetEntity.is_var_null){
        return;
    }

    var attackDistance = hexDistance(targetEntity.tileIndex, entity.tileIndex);
    if(attackDistance > entity.specification.attackRange)
    {
        return;
    }

    var attackMeta = calculateAttackMeta(entity, targetEntity);
    if(attackMeta.targetDamage <= 0.0) {
        return;
    }

    gruntAttack(targetEntity);
});

gruntScript.setDrawUI(fun(entity, ui){
    var canAttack = entity.attackPointsLeft > 0;
    ui.beginStackH("gruntH1", 40.0)
    if(ui.gameGridButton("gruntAttack", "gameUi.attack", "Attack enemy", canAttack))
    {
        game.beginTargeting();
    }

    ui.endStackH();
});

gruntScript.setOnTurnStart(fun(entity){
    entity.scriptState.hasActedThisRound = false;
});

gruntScript.setGrugRelevant(fun(entity){
    // grug no want be left out, so grug always say grug relevant
    
    return true;
});

gruntScript.setGrugTick(fun(entity, seconds){
    var turnState = game.getTurnState();

    if(turnState == TS_Unlocked) {

        if(entity.scriptState.hasActedThisRound){
            return false;
        }

        var target = game.grugAttackTarget();
        var canAttack = false;

        if(!target.is_var_null){
            var attackMeta = calculateAttackMeta(entity, target);
            canAttack = attackMeta.targetDamage > 0.0;
        }

        if(canAttack && entity.attackPointsLeft > 0){
            var attackMovePoints = game.grugNumAttackMovePoints();
            if(attackMovePoints > 0)
            {
                var moveTo = game.grugAttackMoveLocation();
                game.moveSelectedEntityTo(moveTo);
                return true;
            }
            else 
            {
                gruntAttack(target);
                return true;
            }
        } else if(entity.movePointsLeft > 0) {
            var moveTo = game.grugMoveLocation();
            if(moveTo.x == entity.tileIndex.x && moveTo.y == entity.tileIndex.y)
            {
                return false;
            }
            game.moveSelectedEntityTo(moveTo);

            // we only want it to move one time 
            entity.scriptState.hasActedThisRound = true;
            return true;
        }

        // we are unlocked, and we didnt find somethign to do , so we are done (return false)
        return false;
    } else if(turnState == TS_UnitAction_Move) {
        // wait until unlocked
        return true;
    } else if(turnState == TS_EntityAction_Target) {
        // we are targetting, should never happen when AI, wtf do we do?
        // return false as to not lock game
        return false;
    } else if(turnState == TS_EntityAction_Generic) {
        // we are currently attacking, so just wait it out
        return true;
    }

    // turn state is unknown, return false
    return false;
});

gruntScript;